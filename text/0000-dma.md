- Feature Name: dma_and_device_mapping
- Start Date: 2022-08-12
- RFC PR: [twizzler-rfcs/rfcs#0000](https://github.com/twizzler-operating-system/rfcs/pull/0000)
- Twizzler Issue: [twizzler-operating-system/twizzler#0000](https://github.com/twizzler-operating-system/twizzler/issues/0000)

# Summary
[summary]: #summary

This RFC introduces support for DMA (Direct Memory Access) and bus address mapping for device drivers by providing
kernel support for setting up mappings for objects, kernel APIs for getting lists of physical or bus mappings for
object pages, and twizzler-driver APIs for managing DMA objects and mappings in a memory safe manner.

# Motivation
[motivation]: #motivation

DMA is a fundamental aspect of writing device drivers, as devices use DMA to transfer data to and
from host memory. However, thinking of devices accessing host memory solely via single one-shot DMA
transfers is an outdated and limited model. The goal of this RFC is to provide a unified mechanism
for supplying devices with bus addresses that correspond to physical memory that backs object memory
in such a way that drivers can program both "streaming" (e.g. buffers) and "long-term-bidirectional"
(e.g. command rings) memory.

# Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

## Considerations for DMA

When programs access memory in Twizzler they do so via accessing object memory, which involves an
MMU translating some kind of object address to a physical address. On x86, for example, this
involves a software translation to a virtual address followed by a translation via the Memory
Management Unit (MMU) to a physical address. Similarly, when a device accesses memory, it emits a
memory address (likely programmed by the driver) that may undergo no translation or some other
translation on the bus before attempting to access host memory. There are two important
considerations that are the result of this alternate (or no) translation:

 - **Contiguous addresses**. While object memory is contiguous (within an object), the physical
   memory that backs that object memory may not be. Thus devices and drivers need to be capable of
   handling access to memory in a scatter-gather manner.
 - **Access Control**. Access control can be applied differently between host-side driver software
   and devices. Thus driver software must be aware that it may have access to memory via the device
   that it should not directly. We can use devices like the IOMMU to limit this effect.

In addition to the above, we need to consider the issue of coherence. While CPU caches are coherent
across cores, devices accessing host memory do not necessarily invalidate caches. Thus we have to
handle both flushing data to main-memory after writing before the device reads it and invalidating
caches if a device writes to memory. Some systems automatically invalidate caches, but not all do.

### Memory Safety

Finally, we must consider memory safety. This is an issue because while we can control writes from
host software to DMA buffers, we cannot necessarily control how *the device* will access that
memory. To ensure memory safety of shared regions, we would need to ensure:

 1. The device and host software cannot both mutate shared state at the same time (thread safety).
    Note that this *may* be okay in some situations, such as atomic variables that are updated from
    the device without tearing possibility or touch neighboring memory, however encoding this at
    compile time to prove safety may be impossible in general.
 2. The device mutates data such that each mutation is valid for the ABI of the type of the memory
    region.
 
Enforcing these at all times may cause overhead and increase API complexity. Another stance we could
take is Rust's approach to "external influences on memory", such as [accessing /proc/self/mem on
UNIX](https://doc.rust-lang.org/std/os/unix/io/index.html#procselfmem-and-similar-os-features),
which is basically to say that this is outside the scope of the compiler's ability to ensure safety.
I think, though, that since programming shared access between driver software and the device is a
fundamental part of driver software development, some middle ground that provides some safety is
desireable, even if it means reaching for some unsafe here and there (possibly merely for efficiency).

## Using DMA in a Device Driver

Twizzler will provide an interface for making a single Twizzler object accessible to a device by way
of the `DmaObject` type exposed by the twizzler-driver crate. The DmaObject can be created from any
Twizzler object, and exposes APIs for ensuring coherence and memory safety. Let's take as example a
device that has a command ring buffer that is used to submit commands and to indicate when a command
has been completed. A command in the ring buffer can point to another DMA buffer that is used to
transfer data, and may look like the following:

```{rust}
struct Command {
    op: u32,
    status: u32,
    buffer: u64,
}
```

The `op` field specifies some operation to perform (send packet, etc.), the `status` field specifies
the result of the command (say, for example, is set to 1 when the command is completed and must be
cleared to zero for a command to be processed). Finally, the `buffer` field points to the physical
address of some buffer. Let's also imagine some mechanism for communicating to the device the head
of the ring so that we might communicate to the device a collection of new commands to process via
a write to some MMIO register. For the sake of simplicity, let's assume that the buffer is at most 1
page long.

Setting up some DMA regions may look like:

```{rust}
let object = create_new_object();
let dma = DmaObject::new(object);

let command_ring = dma.slice::<Command, some_command_len>(Access::BiDirectional, DmaOptions::default());
let buffer = dma.slice::<u8, some_buffer_len>(Access::HostToDevice, DmaOptions::default());
```

At this point, both command_ring and buffer have types `DmaRegion<[Command; N]>` and `DmaRegion<[u8;N]>` 
respectively. We can then use `DmaRegion::pin()` to get a list of physical pages associated with the
region so that we may program the device to operate on this command ring. Then, submitting a command
would look like:

```{rust}
buffer.with_mut(0..0x1000, |buf| {
    fill_out_buffer(buf);
});
// Grab a 'pin'of the buffer, which ensures that the associated physical addresses and IOMMU maps will remain static until the dma object is dropped.
let buffer_pin = buffer.pin();
// Get the physical address of the first page.
let buffer_addr = buffer_pin[0].addr();
// Fill out a new command.
command_ring.with_mut(0..1, |ring| {
    ring[0] = Command::new(buffer_addr);
});
increment_head();
```

A pin object can manually release the pages it refers to, but otherwise the lifetime of pinned
physical memory is the same as the DmaObject itself. By tying pin lifetime to the DMA object and not
the pin object reduces management complexity of
avoiding accidentally programming a device with stale physical addresses.

The `DmaRegion::with_mut` function runs a closure while ensuring (some level of) safety. Before the
closure, it ensures any writes from the device are visible, and after running the closure, it
ensures that any writes made by driver software are visible to the device. A similar function, `with`,
allows driver software to read the DMA region and not write it, allowing the system to skip ensuring
coherent writes from host to device.

## Simple Allocation

If a driver needs to allocate a large number of dynamically sized DMA regions, doing so with a
single object may prove difficult as we can easily run out of space. Thus twizzler-driver also
provides a type for managing a collection of DmaObjects all of a similar type: `DmaPool`. We can use
it as follows:

```{rust}
let pool = DmaPool::new(DmaPool::default_spec(), Access::HostToDevice, DmaOptions::default());
let region = pool.allocate::<Foo>(Foo::default());
// Dropping region causes it to deallocate.
```

## Coherence Models and Memory Safety

In the above example, we used default DMA options, which ensures the following:

 1. Writes by host software are readable by the device once the `with_mut` function returns.
 2. Coherence is synchronized at the start of the `with` or `with_mut` calls.

More relaxed models are available that do not do any synchronization unless the driver explicitly
calls `DmaRegion::sync`. Note that we are *not* ensuring that no memory access conflicts occur
between the device and driver software, since that is not possible to do at compile time or
runtime[^1]. We are further not ensuring that the device maintains the ABI of the `Command` type. In
this example, this doesn't really matter, as all the constituents of this type are simple integers,
but imagine instead that `status` was an enum with only a few defined values. The device could
update the value of status to a non-defined value, which would cause problems.

To avoid the type ABI problem, we require that a region be a type that implements the `DeviceSync`
and `Copy` marker traits. The `DeviceSync` trait is a promise that the ABI for the type can handle
any update to it that the device might make and that it can handle possible memory conflicts with writes
from the device.

[^1]: *Efficiently*, anyway. See, we could use the IOMMU to ensure that physical addresses are only
    available for the device to access during certain windows. However, this would involve a LOT of
    system calls and IOMMU reprogramming, which is currently not terribly fast. Note, however, that
    as-written this API would allow for this kind of enforcement if we choose to do it in the future.

# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

This is the technical portion of the RFC. Explain the design in sufficient detail that:

- Its interaction with other features is clear.
- It is reasonably clear how the feature would be implemented.
- Corner cases are dissected by example.

The section should return to the examples given in the previous section, and explain more fully how the detailed proposal makes those examples work.

# Drawbacks
[drawbacks]: #drawbacks

Why should we *not* do this?

# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

- Why is this design the best in the space of possible designs?
- What other designs have been considered and what is the rationale for not choosing them?
- What is the impact of not doing this?

# Prior art
[prior-art]: #prior-art

Discuss prior art, both the good and the bad, in relation to this proposal.
A few examples of what this can include are:

- Does this feature exist in other operating systems and what experience have their community had?
- For community proposals: Is this done by some other community and what were their experiences with it?
- For other teams: What lessons can we learn from what other communities have done here?
- Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background.

This section is intended to encourage you as an author to think about
the lessons from other systems, provide readers of your RFC with a
fuller picture.  If there is no prior art, that is fine - your ideas
are interesting to us whether they are brand new or if it is an
adaptation from other operating systems.

Note that while precedent set by other operating systems is some
motivation, it does not on its own motivate an RFC.

# Unresolved questions
[unresolved-questions]: #unresolved-questions

- What parts of the design do you expect to resolve through the RFC process before this gets merged?
- What parts of the design do you expect to resolve through the implementation of this feature before stabilization?
- What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?

# Future possibilities
[future-possibilities]: #future-possibilities

Think about what the natural extension and evolution of your proposal
would be and how it would affect the operating system and project as a
whole in a holistic way. Try to use this section as a tool to more
fully consider all possible interactions with the project and system
in your proposal.  Also consider how this all fits into the roadmap
for the project and of the relevant sub-team.

This is also a good place to "dump ideas", if they are out of scope for the
RFC you are writing but otherwise related.

If you have tried and cannot think of any future possibilities,
you may simply state that you cannot think of anything.

Note that having something written down in the future-possibilities section
is not a reason to accept the current or a future RFC; such notes should be
in the section on motivation or rationale in this or subsequent RFCs.
The section merely provides additional information.
